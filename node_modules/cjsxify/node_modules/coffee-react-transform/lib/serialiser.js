// Generated by CoffeeScript 1.7.1
var $, HTML_ELEMENTS, SPACES_ONLY, TEXT_LEADING_WHITESPACE, TEXT_TRAILING_WHITESPACE, WHITESPACE_ONLY, containsNewlines, genericBranchSerialiser, genericLeafSerialiser, inspect, last, occurrences, serialise, serialiseNode, serialisers, stringEscape;

last = require('./helpers').last;

inspect = require('util').inspect;

$ = require('./symbols');

HTML_ELEMENTS = require('./htmlelements');

stringEscape = require('./stringescape');

occurrences = require('./occurrences');

module.exports = serialise = function(parseTree) {
  var env;
  env = {
    serialiseNode: serialiseNode
  };
  if (parseTree.children && parseTree.children.length && parseTree.children[0].type === $.CJSX_PRAGMA) {
    env.domObject = parseTree.children[0].value;
  } else {
    env.domObject = 'React.DOM';
  }
  return env.serialiseNode(parseTree);
};

serialiseNode = function(node) {
  var serialised;
  if (serialisers[node.type] == null) {
    throw new Error("unknown parseTree node type " + node.type);
  }
  serialised = serialisers[node.type](node, this);
  if (!(typeof serialised === 'string' || serialised === null)) {
    throw new Error("serialiser " + node.type + " didn\'t return a string for node " + (inspect(node)) + ", instead returned " + serialised);
  }
  return serialised;
};

genericBranchSerialiser = function(node, env) {
  return node.children.map(function(child) {
    return env.serialiseNode(child);
  }).join('');
};

genericLeafSerialiser = function(node, env) {
  return node.value;
};

serialise.serialisers = serialisers = {
  ROOT: genericBranchSerialiser,
  CJSX_PRAGMA: function() {
    return null;
  },
  CJSX_EL: function(node, env) {
    var accumulatedWhitespace, child, prefix, serialisedChild, serialisedChildren, _i, _len, _ref;
    serialisedChildren = [];
    accumulatedWhitespace = '';
    _ref = node.children;
    for (_i = 0, _len = _ref.length; _i < _len; _i++) {
      child = _ref[_i];
      serialisedChild = env.serialiseNode(child);
      if (child != null) {
        if (WHITESPACE_ONLY.test(serialisedChild)) {
          accumulatedWhitespace += serialisedChild;
        } else {
          serialisedChildren.push(accumulatedWhitespace + serialisedChild);
          accumulatedWhitespace = '';
        }
      }
    }
    if (serialisedChildren.length) {
      serialisedChildren[serialisedChildren.length - 1] += accumulatedWhitespace;
      accumulatedWhitespace = '';
    }
    prefix = HTML_ELEMENTS[node.value] != null ? env.domObject + '.' : '';
    return prefix + node.value + '(' + serialisedChildren.join(', ') + ')';
  },
  CJSX_ESC: function(node, env) {
    var childrenSerialised;
    childrenSerialised = node.children.map(function(child) {
      return env.serialiseNode(child);
    }).join('');
    return '(' + childrenSerialised + ')';
  },
  CJSX_ATTRIBUTES: function(node, env) {
    var child, childIndex, indexOfLastSemanticChild, isBeforeLastSemanticChild, semanticChildren, serialisedChild, serialisedChildren, whitespaceChildren, _ref;
    _ref = node.children.reduce(function(partitionedChildren, child) {
      if (child.type === $.CJSX_WHITESPACE) {
        partitionedChildren[0].push(child);
      } else {
        partitionedChildren[1].push(child);
      }
      return partitionedChildren;
    }, [[], []]), whitespaceChildren = _ref[0], semanticChildren = _ref[1];
    indexOfLastSemanticChild = node.children.lastIndexOf(last(semanticChildren));
    isBeforeLastSemanticChild = function(childIndex) {
      return childIndex < indexOfLastSemanticChild;
    };
    if (semanticChildren.length) {
      serialisedChildren = (function() {
        var _i, _len, _ref1, _results;
        _ref1 = node.children;
        _results = [];
        for (childIndex = _i = 0, _len = _ref1.length; _i < _len; childIndex = ++_i) {
          child = _ref1[childIndex];
          serialisedChild = env.serialiseNode(child);
          if (child.type === $.CJSX_WHITESPACE) {
            if (containsNewlines(serialisedChild)) {
              if (isBeforeLastSemanticChild(childIndex)) {
                _results.push(serialisedChild.replace('\n', ' \\\n'));
              } else {
                _results.push(serialisedChild);
              }
            } else {
              _results.push(null);
            }
          } else if (isBeforeLastSemanticChild(childIndex)) {
            _results.push(serialisedChild + ', ');
          } else {
            _results.push(serialisedChild);
          }
        }
        return _results;
      })();
      return '{' + serialisedChildren.join('') + '}';
    } else {
      return 'null';
    }
  },
  CJSX_ATTR_PAIR: function(node, env) {
    return node.children.map(function(child) {
      return env.serialiseNode(child);
    }).join(': ');
  },
  CS: genericLeafSerialiser,
  CS_COMMENT: genericLeafSerialiser,
  CS_HEREDOC: genericLeafSerialiser,
  CS_STRING: genericLeafSerialiser,
  CS_REGEX: genericLeafSerialiser,
  CS_HEREGEX: genericLeafSerialiser,
  JS_ESC: genericLeafSerialiser,
  CJSX_WHITESPACE: genericLeafSerialiser,
  CJSX_TEXT: function(node) {
    var leftSpace, leftTrim, rightSpace, rightTrim, text, trimmedText;
    text = node.value;
    if (containsNewlines(text)) {
      if (WHITESPACE_ONLY.test(text)) {
        return text;
      } else {
        leftSpace = text.match(TEXT_LEADING_WHITESPACE);
        rightSpace = text.match(TEXT_TRAILING_WHITESPACE);
        if (leftSpace) {
          leftTrim = text.indexOf('\n');
        } else {
          leftTrim = 0;
        }
        if (rightSpace) {
          rightTrim = text.lastIndexOf('\n') + 1;
        } else {
          rightTrim = text.length;
        }
        trimmedText = text.substring(leftTrim, rightTrim);
        return '"""' + trimmedText + '"""';
      }
    } else {
      if (text === '') {
        return null;
      } else {
        return '"' + text + '"';
      }
    }
  },
  CJSX_ATTR_KEY: genericLeafSerialiser,
  CJSX_ATTR_VAL: genericLeafSerialiser
};

containsNewlines = function(text) {
  return text.indexOf('\n') > -1;
};

SPACES_ONLY = /^\s+$/;

WHITESPACE_ONLY = /^[\n\s]+$/;

TEXT_LEADING_WHITESPACE = /^\s*?\n\s*/;

TEXT_TRAILING_WHITESPACE = /\s*?\n\s*?$/;
